<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · RestClient.jl</title><meta name="title" content="Tutorial · RestClient.jl"/><meta property="og:title" content="Tutorial · RestClient.jl"/><meta property="twitter:title" content="Tutorial · RestClient.jl"/><meta name="description" content="Documentation for RestClient.jl."/><meta property="og:description" content="Documentation for RestClient.jl."/><meta property="twitter:description" content="Documentation for RestClient.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RestClient.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Basic-setup"><span>Basic setup</span></a></li><li><a class="tocitem" href="#Defining-API-types"><span>Defining API types</span></a></li><li><a class="tocitem" href="#Adding-endpoints"><span>Adding endpoints</span></a></li><li><a class="tocitem" href="#Demonstration"><span>Demonstration</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/tecosaur/RestClient.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/tecosaur/RestClient.jl/blob/main/docs/src/tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><h2 id="Basic-setup"><a class="docs-heading-anchor" href="#Basic-setup">Basic setup</a><a id="Basic-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-setup" title="Permalink"></a></h2><p>To demonstrate how this can simplify API wrapping, in this tutorial we&#39;ll implement a client for the <a href="https://deckofcardsapi.com/">Deck of Cards API</a>. For demonstration purposes, we&#39;ll just wrap part of the API.</p><p>Looking at the API documentation, we can see that</p><ul><li>The base URL is <code>https://deckofcardsapi.com/api/</code></li><li>Decks can be created at the <code>deck/new</code> API (optionally shuffled)</li><li>Operations on a deck occur at <code>deck/&lt;id&gt;/operation</code> endpoints</li></ul><p>That&#39;s it! To get started we&#39;ll create an blank package and call it &quot;DeckAPI&quot; (I did this in my temp directory).</p><pre><code class="nohighlight hljs">pkg&gt; generate DeckAPI
  Generating  project DeckAPI:
    DeckAPI/Project.toml
    DeckAPI/src/DeckAPI.jl</code></pre><p>Then, we activate the project and add <code>JSON3</code> and <code>RestClient</code> as dependencies.</p><pre><code class="nohighlight hljs">pkg&gt; activate DeckAPI

(DeckAPI) pkg&gt; add RestClient JSON3
    Updating `/tmp/DeckAPI/Project.toml`
  [e1389577] + RestClient v0.1.0
  [0f8b85d8] + JSON3 v1.14.1
    Updating `/tmp/DeckAPI/Manifest.toml`
  [...] ...</code></pre><p>Then we can navigate to <code>DeckAPI/src/DeckAPI.jl</code>, get rid of the default <code>greet() = print(&quot;Hello World!&quot;)</code>, and add</p><pre><code class="language-julia hljs">using RestClient, JSON3</code></pre><p>Now we&#39;re ready to get started implementing the API! To start with, we&#39;ll want to create a <a href="../api/#RestClient.RequestConfig"><code>RequestConfig</code></a> to hold the context in which we&#39;re calling the API. This just holds the base URL, a request lock, API access key (optional), and timeout value (optional). The <em>Deck of Cards</em> API is simple enough that we can set a single global <code>RequestConfig</code>, but in a more complex case we might define a utility function to create a <code>RequestConfig</code> based on user-provided parameters.</p><pre><code class="language-julia hljs">const DECK_CONFIG = RequestConfig(&quot;https://deckofcardsapi.com/api&quot;)</code></pre><p>For use with <a href="../api/#RestClient.@endpoint"><code>@endpoint</code></a>-generated functions later, we&#39;ll also declare this to be the global request config for our package.</p><pre><code class="language-julia hljs">RestClient.globalconfig(::Val{DeckAPI}) = DECK_CONFIG</code></pre><p>If we didn&#39;t care about creating the <code>DECK_CONFIG</code> variable, this could be simplified to just <a href="../api/#RestClient.@globalconfig"><code>@globalconfig RequestConfig(...)</code></a>.</p><p>That&#39;s all the setup needed, next we&#39;ll define types for the JSON structures that <em>Desk of Cards</em> can return.</p><h2 id="Defining-API-types"><a class="docs-heading-anchor" href="#Defining-API-types">Defining API types</a><a id="Defining-API-types-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-API-types" title="Permalink"></a></h2><p>Reading the documentation in order, we come across a few types we&#39;ll want to implement. First, there&#39;s the new deck object</p><pre><code class="language-json hljs">{
    &quot;success&quot;: true,
    &quot;deck_id&quot;: &quot;3p40paa87x90&quot;,
    &quot;shuffled&quot;: true,
    &quot;remaining&quot;: 52
}</code></pre><p>Thanks to the <a href="../api/#RestClient.@jsondef"><code>@jsondef</code></a> macro, this is merely a matter of</p><pre><code class="language-julia hljs">@jsondef struct Deck
    # success::Bool # I don&#39;t think we care about this?
    id.&quot;deck_id&quot;::String
    # shuffled::Bool # We should know this anyway?
    remaining::Int
end</code></pre><p>We can also draw cards, which look like this</p><pre><code class="language-julia hljs">@jsondef struct Card
    code::String
    # image # Not needed by us (at the moment)
    value::String
    suit::String
end</code></pre><p>Cards are given as a list in a certain response form, which gives us an opportunity to define a <a href="../api/#RestClient.ListResponse"><code>ListResponse</code></a> subtype.</p><pre><code class="language-julia hljs">@jsondef struct CardsResponse &lt;: ListResponse{Card}
    deck.&quot;deck_id&quot;::String
    remaining::Int
    cards::Vector{Card}
end</code></pre><p>Since we&#39;ve subtyped <code>ListResponse</code>, this will automagically be turned into a <a href="../api/#RestClient.List"><code>List</code></a> holding <code>cards</code>.</p><h2 id="Adding-endpoints"><a class="docs-heading-anchor" href="#Adding-endpoints">Adding endpoints</a><a id="Adding-endpoints-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-endpoints" title="Permalink"></a></h2><p>In <code>RestClient</code>, the bundle of information required to make a request to an endpoint is represented with a dedicated struct, subtyping <a href="../api/#RestClient.AbstractEndpoint"><code>AbstractEndpoint</code></a>.</p><p>The endpoint can then be implemented through the various <em>endpoint interface functions</em> (<a href="../api/#RestClient.pagename"><code>pagename</code></a>, <a href="../api/#RestClient.headers"><code>headers</code></a>, <a href="../api/#RestClient.parameters"><code>parameters</code></a>, <a href="../api/#RestClient.parameters"><code>parameters</code></a>, <a href="../api/#RestClient.responsetype"><code>responsetype</code></a>, and <a href="../api/#RestClient.postprocess"><code>postprocess</code></a>). We&#39;ll start by implementing appropriate methods for the deck creation endpoint, then show how this can be simplified using <a href="../api/#RestClient.@endpoint"><code>@endpoint</code></a> shorthand.</p><h3 id="The-new-deck-endpoint"><a class="docs-heading-anchor" href="#The-new-deck-endpoint">The new deck endpoint</a><a id="The-new-deck-endpoint-1"></a><a class="docs-heading-anchor-permalink" href="#The-new-deck-endpoint" title="Permalink"></a></h3><p>When creating a deck, the number of included 52-card decks and whether it should be shuffled can be specified. So, we create a struct that holds these two pieces of information.</p><pre><code class="language-julia hljs">struct NewDeckEndpoint &lt;: AbstractEndpoint
    count::Int
    shuffle::Bool
end</code></pre><p>This endpoint is located at either <code>deck/new</code> or <code>desk/new/shuffle</code> depending on whether it should be shuffled.</p><pre><code class="language-julia hljs">RestClient.pagename(new::NewDeckEndpoint) = &quot;deck/new&quot; * ifelse(new.shuffle, &quot;/shuffle&quot;, &quot;&quot;)</code></pre><p>The deck count is specified using the <code>deck_count</code> parameter, and so we should add a <a href="../api/#RestClient.parameters"><code>parameters</code></a> method too.</p><pre><code class="language-julia hljs">RestClient.parameters(new::NewDeckEndpoint) = [&quot;deck_count&quot; =&gt; string(new.count)]</code></pre><p>After performing this request, we expect a JSON representation of a <code>Deck</code> to be returned. Since we used <a href="../api/#RestClient.@jsondef"><code>@jsondef</code></a> to create the type, JSON3 will know how to parse it and we need only declare that we expect a <code>Deck</code> response.</p><pre><code class="language-julia hljs">RestClient.responsetype(::NewDeckEndpoint) = Deck</code></pre><p>At this point we can call the endpoint, and create a function for someone using DeckAPI to call.</p><pre><code class="language-julia hljs">new(count::Int = 1; shuffled::Bool = false) =
    perform(Request{:get}(DECK_CONFIG, NewDeckEndpoint(count, shuffled)))</code></pre><p>Next we&#39;ll show how these steps can be performed by a single <a href="../api/#RestClient.@endpoint"><code>@endpoint</code></a> statement.</p><h3 id="Shuffle-endpoint"><a class="docs-heading-anchor" href="#Shuffle-endpoint">Shuffle endpoint</a><a id="Shuffle-endpoint-1"></a><a class="docs-heading-anchor-permalink" href="#Shuffle-endpoint" title="Permalink"></a></h3><p>For the shuffle endpoint, we&#39;ll use <em>some</em> of the capabilities of <a href="../api/#RestClient.@endpoint"><code>@endpoint</code></a> to simplify the declaration of the endpoint location, parameters, and response type.</p><pre><code class="language-julia hljs">@endpoint struct ShuffleEndpoint
    &quot;deck/{deck.id}/shuffle?{remaining}&quot; -&gt; Deck
    deck::Deck
    remaining::Bool
end</code></pre><p>This sets the response type to <code>Deck</code>, the location based on the deck id, and <code>?{remaining}</code> will expand to <code>[&quot;remaining&quot; =&gt; string(self.remaining)]</code>.</p><p>Now we just need to define a function to access this endpoint.</p><pre><code class="language-julia hljs">shuffle(deck::Deck, remaining::Bool=false) =
    perform(Request{:get}(DECK_CONFIG, ShuffleEndpoint(deck, remaining)))</code></pre><h3 id="Draw-endpoint"><a class="docs-heading-anchor" href="#Draw-endpoint">Draw endpoint</a><a id="Draw-endpoint-1"></a><a class="docs-heading-anchor-permalink" href="#Draw-endpoint" title="Permalink"></a></h3><p>The draw endpoint has a similar form to shuffle. You specify a target deck with <code>deck/{deck.id}</code>, but then end with <code>shuffle</code> and specify the number of cards that should be drawn.</p><p>The step of defining an accessor method can also be performed by the <a href="../api/#RestClient.@endpoint"><code>@endpoint</code></a> macro, so long as the appropriate <a href="../api/#RestClient.globalconfig"><code>globalconfig</code></a> method is defined.</p><pre><code class="language-julia hljs">@endpoint draw(deck::Deck, count::Int) -&gt; &quot;deck/{deck.id}/draw?{count}&quot; -&gt; CardsResponse</code></pre><p>A <code>DrawEndpoint</code> struct will automatically be created, and since <code>CardsResponse</code> is <a href="../api/#RestClient.ListResponse"><code>ListResponse</code></a>, the <code>DrawEndpoint</code> struct will subtype <a href="../api/#RestClient.ListEndpoint"><code>ListEndpoint</code></a>. Due to this subtyping, the <code>CardsResponse</code> will automatically be restructured into a <code>List{Card}</code> by the generic list <a href="../api/#RestClient.postprocess"><code>postprocess</code></a> method.</p><h3 id="Card-return-endpoint"><a class="docs-heading-anchor" href="#Card-return-endpoint">Card return endpoint</a><a id="Card-return-endpoint-1"></a><a class="docs-heading-anchor-permalink" href="#Card-return-endpoint" title="Permalink"></a></h3><p>The <em>Deck of Cards</em> API also allows for drawn cards to be returned to the deck. This is slightly more complicated than the other endpoints because you can optionally specify whether specific cards should be returned instead of everything.</p><p>We will account for this by leaving the endpoint parameters out of our <a href="../api/#RestClient.@endpoint"><code>@endpoint</code></a> construction, and then separately defining a <a href="../api/#RestClient.parameters"><code>parameters</code></a> method.</p><pre><code class="language-julia hljs">@endpoint putback(deck::Deck, cards::Union{Nothing, Vector{Card}}) -&gt;
    &quot;deck/{deck.id}/return&quot; -&gt; Deck

function RestClient.parameters(pb::PutbackEndpoint)
    if isnothing(pb.cards)
        Pair{String, String}[]
    else
        [&quot;cards&quot; =&gt; join(map(c -&gt; c.code, pb.cards), &quot;,&quot;)]
    end
end</code></pre><p>Since we can end up with a <code>List{Card}</code> from the draw endpoint, and a <a href="../api/#RestClient.List"><code>List</code></a> contains the original request information (including the deck field of the draw endpoint), we can also provide a <code>putback</code> method that operates on a <code>List{Card}</code> for convenience.</p><pre><code class="language-julia hljs">putback(cardlist::List{Card}) = putback(cardlist.request.endpoint.deck, cardlist.items)</code></pre><h2 id="Demonstration"><a class="docs-heading-anchor" href="#Demonstration">Demonstration</a><a id="Demonstration-1"></a><a class="docs-heading-anchor-permalink" href="#Demonstration" title="Permalink"></a></h2><p>By starting Julia with the environment variable <code>JULIA_DEBUG=RestClient</code> set, we will see information on the requests sent and responses received. This helps us verify that everything is behaving as expected, and debug any failures or unexpected results.</p><pre><code class="language-julia-repl hljs">julia&gt; deck = DeckAPI.new()
┌ Debug:  GET  https://deckofcardsapi.com/api/deck/new?deck_count=1
└ @ RestClient
┌ Debug:  200  80 bytes (saved to /tmp/api-get.dump) from https://deckofcardsapi.com/api/deck/new?deck_count=1
└ @ RestClient
DeckAPI.Deck(id=&quot;01n3ezer3rly&quot;, remaining=52)

julia&gt; cards = DeckAPI.draw(deck, 5)
┌ Debug:  GET  https://deckofcardsapi.com/api/deck/01n3ezer3rly/draw?count=5
└ @ RestClient
┌ Debug:  200  1.181 KiB (saved to /tmp/api-get.dump) from https://deckofcardsapi.com/api/deck/01n3ezer3rly/draw?count=5
└ @ RestClient
RestClient.List{DeckAPI.Card} holding 5 items:
  • Card(code=&quot;AS&quot;, value=&quot;ACE&quot;, suit=&quot;SPADES&quot;)
  • Card(code=&quot;2S&quot;, value=&quot;2&quot;, suit=&quot;SPADES&quot;)
  • Card(code=&quot;3S&quot;, value=&quot;3&quot;, suit=&quot;SPADES&quot;)
  • Card(code=&quot;4S&quot;, value=&quot;4&quot;, suit=&quot;SPADES&quot;)
  • Card(code=&quot;5S&quot;, value=&quot;5&quot;, suit=&quot;SPADES&quot;)

julia&gt; DeckAPI.putback(cards)
┌ Debug:  GET  https://deckofcardsapi.com/api/deck/01n3ezer3rly/return?cards=AS%2C2S%2C3S%2C4S%2C5S
└ @ RestClient
┌ Debug:  200  61 bytes (saved to /tmp/api-get.dump) from https://deckofcardsapi.com/api/deck/01n3ezer3rly/return?cards=AS%2C2S%2C3S%2C4S%2C5S
└ @ RestClient
DeckAPI.Deck(id=&quot;01n3ezer3rly&quot;, remaining=52)

julia&gt; DeckAPI.shuffle(deck)
┌ Debug:  GET  https://deckofcardsapi.com/api/deck/01n3ezer3rly/shuffle?remaining=false
└ @ RestClient
┌ Debug:  200  79 bytes (saved to /tmp/api-get.dump) from https://deckofcardsapi.com/api/deck/01n3ezer3rly/shuffle?remaining=false
└ @ RestClient
DeckAPI.Deck(id=&quot;01n3ezer3rly&quot;, remaining=52)

julia&gt; cards = DeckAPI.draw(deck, 5)
┌ Debug:  GET  https://deckofcardsapi.com/api/deck/01n3ezer3rly/draw?count=5
└ @ RestClient
┌ Debug:  200  1.183 KiB (saved to /tmp/api-get.dump) from https://deckofcardsapi.com/api/deck/01n3ezer3rly/draw?count=5
└ @ RestClient
RestClient.List{DeckAPI.Card} holding 5 items:
  • Card(code=&quot;3C&quot;, value=&quot;3&quot;, suit=&quot;CLUBS&quot;)
  • Card(code=&quot;QC&quot;, value=&quot;QUEEN&quot;, suit=&quot;CLUBS&quot;)
  • Card(code=&quot;4S&quot;, value=&quot;4&quot;, suit=&quot;SPADES&quot;)
  • Card(code=&quot;2D&quot;, value=&quot;2&quot;, suit=&quot;DIAMONDS&quot;)
  • Card(code=&quot;3S&quot;, value=&quot;3&quot;, suit=&quot;SPADES&quot;)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 8 December 2024 11:27">Sunday 8 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
